---
alwaysApply: true
---

# Flutter 项目 Cursor 规则文件

# 基于 zjs_flutter_template 项目架构和最佳实践

## 项目概述

这是一个基于Flutter的企业级应用模板。项目采用现代化的架构模式，包含完整的状态管理、网络请求、本地存储、国际化、主题切换等功能。

## 技术栈

- **框架**: Flutter 3.0+, Dart 3.0+
- **状态管理**: Riverpod + Riverpod Generator
- **路由**: GoRouter
- **网络**: Dio + Pretty Dio Logger
- **依赖注入**: GetIt + Injectable
- **本地存储**: SharedPreferences, Hive, Flutter Secure Storage
- **国际化**: flutter_localizations, intl
- **UI适配**: ScreenUtil
- **函数式编程**: Dartz
- **代码生成**: Freezed, JSON Serializable, Build Runner
- **监控**: 自定义监控系统（预留Firebase/Sentry接口）

## 项目结构

```
lib/
├── config/           # 配置文件（环境、语言、路由、主题）
├── core/            # 核心功能（常量、错误处理、网络、存储、工具）
├── di/              # 依赖注入配置
├── features/        # 功能模块（页面、状态管理）
├── shared/          # 共享资源（API、模型、服务、组件）
├── generated/       # 生成的代码
└── main.dart        # 应用入口
```

## 编码规范

### 1. 文件命名和组织

- 使用 snake_case 命名文件和文件夹
- 按功能模块组织代码，遵循清洁架构原则
- 将相关文件放在同一目录下
- 使用有意义的文件名，避免缩写

### 2. 代码风格

- 严格遵循 Dart 官方代码规范
- 使用 `very_good_analysis` 和 `flutter_lints` 进行代码检查
- 优先使用 `final` 关键字
- 避免使用 `dynamic`，明确指定类型
- 使用 `const` 构造函数提高性能

### 3. 导入规范

```dart
// 1. Dart 核心库
import 'dart:async';
import 'dart:convert';

// 2. Flutter 库
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

// 3. 第三方包（按字母顺序）
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

// 4. 项目内部导入（按字母顺序）
import 'package:zjs_flutter_template/core/utils/logger.dart';
import 'package:zjs_flutter_template/shared/models/user.dart';
```

## 架构模式

### 1. 状态管理 - Riverpod

- 使用 `@riverpod` 注解生成 Provider
- 优先使用 `AsyncNotifier` 处理异步状态
- 使用 Freezed 定义不可变状态类
- 状态类必须包含加载、错误、成功状态

```dart
@riverpod
class ExampleNotifier extends _$ExampleNotifier {
  @override
  FutureOr<ExampleState> build() {
    return const ExampleState.initial();
  }

  Future<void> performAction() async {
    state = const AsyncValue.loading();
    try {
      final result = await _service.fetchData();
      state = AsyncValue.data(ExampleState.success(result));
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }
}
```

### 2. 依赖注入 - GetIt + Injectable

- 使用 `@injectable` 注解自动注册服务
- 优先使用单例模式 `@singleton`
- 在 `service_locator.dart` 中集中管理依赖
- 使用 `getIt<T>()` 获取服务实例

```dart
@singleton
class ExampleService {
  ExampleService(this._apiClient);
  
  final ApiClient _apiClient;
  
  Future<Result> performOperation() async {
    // 实现逻辑
  }
}
```

### 3. 错误处理

- 使用 Dartz 的 `Either<Failure, Success>` 模式
- 自定义异常类继承 `AppException`
- 在 Repository 层处理错误转换
- 使用全局错误处理器捕获未处理异常

```dart
Future<Either<Failure, User>> getUser(String id) async {
  try {
    final response = await _apiClient.get('/users/$id');
    final user = User.fromJson(response.data);
    return Right(user);
  } on AppException catch (e) {
    return Left(ServerFailure(e.message));
  } catch (e) {
    return Left(ServerFailure('未知错误'));
  }
}
```

### 4. 网络请求

- 统一使用 `ApiClient` 进行网络请求
- 在 Repository 层封装 API 调用
- 使用拦截器处理认证、日志、重试等
- 定义统一的 API 响应格式

### 5. 本地存储

- 使用 `StorageService` 统一管理存储
- 敏感数据使用 `FlutterSecureStorage`
- 复杂数据使用 Hive
- 简单配置使用 SharedPreferences

## UI/UX 规范

### 1. 主题系统

- 使用 `AppTheme` 统一管理主题
- 支持亮色/暗色主题切换
- 使用 `AppColors` 定义颜色系统
- 使用 `AppTextStyles` 定义文字样式
- 适老化设计，提供大字体和高对比度选项

### 2. 响应式设计

- 使用 `ScreenUtil` 进行屏幕适配
- 设计稿基准：iPhone 14 Pro (393x852)
- 使用 `.w` `.h` `.sp` `.r` 进行尺寸适配
- 支持横屏和分屏模式

### 3. 组件规范

- 优先使用 Material 3 组件
- 自定义组件放在 `shared/widgets/` 目录
- 组件必须支持主题切换
- 提供完整的文档和示例

### 4. 导航规范

- 使用 GoRouter 进行路由管理
- 路由路径定义在 `route_paths.dart`
- 使用路由守卫处理权限验证
- 支持深链接和状态恢复

## 国际化

### 1. 多语言支持

- 使用 `flutter_localizations` 实现国际化
- 主语言：中文（zh_CN）
- 支持语言：英语（en）
- ARB 文件位置：`lib/l10n/`

### 2. 文本规范

```dart
// 使用 S.of(context) 获取本地化文本
Text(S.of(context).welcome_message)

// 带参数的文本
Text(S.of(context).user_greeting(userName))
```

## 测试规范

### 1. 测试类型

- **单元测试**: 测试业务逻辑和工具函数
- **Widget测试**: 测试UI组件
- **集成测试**: 测试完整用户流程

### 2. 测试文件组织

```
test/
├── unit/           # 单元测试
├── widget/         # Widget测试
└── integration/    # 集成测试
```

### 3. Mock规范

- 使用 Mockito 创建 Mock 对象
- Repository 和 Service 层必须提供 Mock 实现
- 网络请求使用 Mock 数据

## 性能优化

### 1. 内存管理

- 及时释放资源和监听器
- 使用 `const` 构造函数
- 避免在 build 方法中创建对象
- 使用 `ListView.builder` 处理长列表

### 2. 网络优化

- 实现请求缓存机制
- 使用连接池复用连接
- 图片使用 `CachedNetworkImage`
- 实现离线缓存

### 3. 构建优化

- 使用 `flutter build` 的优化选项
- 启用代码混淆和压缩
- 移除未使用的资源
- 使用 Tree Shaking 减少包大小

## 安全规范

### 1. 数据安全

- 敏感数据使用加密存储
- API 请求使用 HTTPS
- 实现 Certificate Pinning
- 定期清理敏感数据

### 2. 认证授权

- 使用 JWT Token 进行身份验证
- 实现 Token 自动刷新机制
- 支持多因子认证
- 实现会话超时管理

## 监控和日志

### 1. 日志系统

- 使用 `AppLogger` 统一日志管理
- 不同环境使用不同日志级别
- 生产环境禁止输出敏感信息
- 实现日志文件轮转

### 2. 错误监控

- 集成 Sentry 或 Firebase Crashlytics
- 自动收集崩溃信息
- 实现自定义错误报告
- 提供错误恢复机制

### 3. 性能监控

- 监控应用启动时间
- 跟踪页面加载性能
- 监控内存使用情况
- 收集用户行为数据

## 代码生成

### 1. 必需的生成命令

```bash
# 生成所有代码
dart run build_runner build --delete-conflicting-outputs

# 监听文件变化
dart run build_runner watch --delete-conflicting-outputs
```

### 2. 生成的文件类型

- Riverpod Provider (*.g.dart)
- Freezed 模型 (*.freezed.dart)
- JSON 序列化 (*.g.dart)
- GetIt 配置 (service_locator.config.dart)

## Git 工作流

### 1. 分支策略

- `main`: 生产分支
- `develop`: 开发分支  
- `feature/*`: 功能分支
- `hotfix/*`: 热修复分支

### 2. 提交规范

```
feat: 新功能
fix: 修复bug
docs: 文档更新
style: 代码格式调整
refactor: 重构
test: 测试相关
chore: 构建过程或辅助工具变动
```

### 3. Pull Request 规范

- 提供清晰的PR描述
- 包含测试用例
- 通过所有CI检查
- 至少一人代码审查

## 部署和发布

### 1. 环境配置

- 开发环境：连接测试服务器
- 测试环境：连接测试服务器
- 生产环境：连接正式服务器

### 2. 版本管理

- 遵循语义化版本控制
- 更新 `pubspec.yaml` 版本号
- 生成 Release Notes
- 创建 Git 标签

### 3. CI/CD 流程

- 自动化测试
- 代码质量检查
- 自动构建和打包
- 自动化部署

## 最佳实践

### 1. 代码质量

- 保持函数简短，单一职责
- 使用有意义的变量名
- 添加必要的注释和文档
- 定期重构代码

### 2. 团队协作

- 定期代码审查
- 统一开发环境配置
- 分享最佳实践
- 持续学习和改进

### 3. 用户体验

- 优化应用启动速度
- 提供流畅的动画效果
- 实现优雅的错误处理
- 支持无障碍访问

---

## 特定于本项目的规则

### 项目特定的文件路径规范

- 主题配置：`lib/config/themes/app_theme.dart`
- 路由配置：`lib/config/routes/app_router.dart`
- 依赖注入：`lib/di/service_locator.dart`
- API服务：`lib/shared/apis/`
- 数据模型：`lib/shared/models/`
- 业务服务：`lib/shared/services/`
- 页面组件：`lib/features/pages/`
- 状态管理：`lib/features/providers/`

遵循这些规则将确保代码质量、可维护性和团队协作效率。定期更新这些规则以适应项目发展需要。
